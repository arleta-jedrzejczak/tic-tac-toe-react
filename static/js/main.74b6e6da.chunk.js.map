{"version":3,"sources":["constants/results.constant.jsx","components/square.component.jsx","components/button.component.jsx","components/score.component.jsx","App.js","serviceWorker.js","index.js"],"names":["resultsArray","Square","props","isPlaying","className","onClick","clickHandler","isClicked","isPlayer1Owned","Button","Score","isWon","isPlayerOne","isDraw","App","initialState","player1Fields","player2Fields","fields","prepareFields","state","this","length","checkFields","isPlayerOneResults","isNotUnclickedField","find","element","playerResultsArray","i","a","b","c","includes","setState","drawGame","field","map","item","index","itemField","updatePlayersArrays","changeTurn","sort","endGame","startGame","buttonClickHandler","bind","key","id","fieldClickHandler","push","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.74b6e6da.chunk.js","sourcesContent":["export const resultsArray = [\r\n    [0, 3, 6],\r\n    [1, 4, 7],\r\n    [2, 5, 8],\r\n    [0, 1, 2],\r\n    [3, 4, 5],\r\n    [6, 7, 8],\r\n    [0, 4, 8],\r\n    [2, 4, 6]\r\n];\r\n","import React from 'react';\r\n\r\nconst Square = (props) => {\r\n    if (props.isPlaying) {\r\n        return (\r\n            <div className=\"field\" onClick={props.clickHandler}>\r\n                {props.isClicked &&\r\n                <h2>{props.isPlayer1Owned ? 'o' : 'x'}</h2>\r\n                }\r\n            </div>\r\n        )\r\n    } else {\r\n        return(null);\r\n    }\r\n};\r\n\r\nexport default Square;\r\n","import React from 'react';\r\n\r\nconst Button = (props) => {\r\n    return (\r\n        <button onClick={props.clickHandler}>{props.isPlaying ? 'End game' : 'Start game'}</button>\r\n    )\r\n};\r\n\r\nexport default Button;\r\n","import React from 'react';\r\n\r\nconst Score = (props) => {\r\n    if (props.isWon)\r\n        return (\r\n            <div>The winner is {props.isPlayerOne ? 'Player 1' : 'Player 2'}</div>\r\n        );\r\n    if (props.isDraw)\r\n        return (\r\n            <div>Draw!</div>\r\n        );\r\n    return null;\r\n};\r\n\r\nexport default Score;\r\n","import React, {Component} from 'react';\nimport {resultsArray} from './constants/results.constant';\nimport './App.css';\nimport Square from \"./components/square.component\";\nimport Button from \"./components/button.component\";\nimport Score from \"./components/score.component\";\n\nclass App extends Component {\n\n    constructor() {\n        super();\n    }\n\n    initialState = {\n        isPlaying: false,\n        isPlayerOne: false,\n        isWon: false,\n        isDraw: false,\n        player1Fields: [],\n        player2Fields: [],\n        fields: App.prepareFields()\n    };\n\n    state = {\n        ...this.initialState\n    };\n\n    static prepareFields() {\n        let fields = [];\n        for (let i = 0; i < 9; i++) {\n            fields.push({\n                isClicked: false,\n                isPlayer1Owned: false\n            })\n        }\n        return fields;\n    }\n\n    componentDidUpdate() {\n        // wired conditions: componentDidUpdate is fired after changeTurn\n        if (this.state.isPlayerOne && this.state.player2Fields.length >= 3) {\n            this.checkFields(false);\n        } else if (!this.state.isPlayerOne && this.state.player1Fields.length >= 3) {\n            this.checkFields(true);\n        }\n    }\n\n    checkFields(isPlayerOneResults) {\n        const isNotUnclickedField = !this.state.fields.find((element) => element.isClicked === false);\n        let playerResultsArray = isPlayerOneResults ? this.state.player1Fields : this.state.player2Fields;\n        for (let i = 0; i < resultsArray.length; i++) {\n            let a = resultsArray[i][0];\n            let b = resultsArray[i][1];\n            let c = resultsArray[i][2];\n            if (playerResultsArray.includes(a) && playerResultsArray.includes(b) && playerResultsArray.includes(c) && !this.state.isWon) {\n                this.setState({\n                    isWon: true,\n                    isPlaying: false\n                });\n            }\n        } if (isNotUnclickedField && !this.state.isDraw) {\n            this.drawGame();\n        }\n    }\n\n    drawGame() {\n        this.setState({\n            isDraw: true,\n            isPlaying: false\n        });\n    }\n\n    fieldClickHandler(field) {\n        if (!this.state.fields[field].isClicked) {\n            this.setState(state => {\n                const fields = state.fields.map((item, index) => {\n                    let itemField = {...item};\n                    if (field === index) {\n                        itemField.isClicked = true;\n                        this.state.isPlayerOne ? (itemField.isPlayer1Owned = true) : (itemField.isPlayer1Owned = false);\n                    }\n                    return itemField;\n                });\n                return {\n                    fields,\n                };\n            });\n            this.updatePlayersArrays(field);\n            this.changeTurn();\n        }\n    }\n\n    updatePlayersArrays(field) {\n        this.setState((state) => {\n            let player1Fields, player2Fields;\n            if (state.isPlayerOne) {\n                player1Fields = [...state.player1Fields, field];\n                player1Fields.sort((a, b) => a - b);\n                return {player1Fields};\n            } else {\n                player2Fields = [...state.player2Fields, field];\n                player2Fields.sort((a, b) => a - b);\n                return {player2Fields};\n            }\n        });\n    }\n\n    changeTurn() {\n        this.setState({\n            isPlayerOne: !this.state.isPlayerOne\n        })\n    }\n\n    buttonClickHandler() {\n        this.state.isPlaying ? this.endGame() : this.startGame();\n    }\n\n    startGame() {\n        this.setState(() => {\n            const isPlaying = true;\n            const isPlayerOne = true;\n            return {\n                ...this.initialState,\n                isPlaying,\n                isPlayerOne\n            }\n        });\n    }\n\n    endGame() {\n        this.setState({\n            ...this.initialState\n        })\n    }\n\n    render() {\n        return (\n            <div>\n                <Button clickHandler={this.buttonClickHandler.bind(this)} isPlaying={this.state.isPlaying}/>\n                <div className=\"fieldsWrapper\">\n                    {\n                        this.state.fields.map((field, index) => {\n                            return (\n                                <Square key={index} id={index} isClicked={field.isClicked}\n                                        isPlayer1Owned={field.isPlayer1Owned} isPlaying={this.state.isPlaying}\n                                        clickHandler={this.fieldClickHandler.bind(this, index)}/>\n                            );\n                        })\n                    }\n                </div>\n                <Score isWon={this.state.isWon} isPlayerOne={!this.state.isPlayerOne} isDraw={this.state.isDraw}/>\n            </div>\n        )\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport '../node_modules/bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}